[["index.html", "Quantitative Ecology Modelling applications in population ecology Chapter 1 Prerequisites", " Quantitative Ecology Modelling applications in population ecology Matt Weldy 2021-03-05 Chapter 1 Prerequisites This is a work in progress. The scope of this work is to demonstrate the fit of well known ecological models using a variety of tools. Our aim is to provide brief model descriptions, primary citations, and a simple simulation and model fit. Contributions to this web page are welcome, and can be made through the books github repository. The website is hosted through netlify, which offers continuous integration with the books git repository. Commit changes to the repository after using the bookdown and changes will populate to the page. Please try to structure indivudal model fits using the template outlined in Appendix B. bookdown::render_book(&quot;index.Rmd&quot;, &quot;bookdown::gitbook&quot;) "],["intro.html", "Chapter 2 Introduction", " Chapter 2 Introduction You can label chapter and section titles using {#label} after them, e.g., we can reference Chapter 2. If you do not manually label them, there will be automatic labels anyway, e.g., Chapter ??. Figures and tables with captions will be placed in figure and table environments, respectively. par(mar = c(4, 4, .1, .1)) plot(pressure, type = &#39;b&#39;, pch = 19) Figure 2.1: Here is a nice figure! Reference a figure by its code chunk label with the fig: prefix, e.g., see Figure 2.1. Similarly, you can reference tables generated from knitr::kable(), e.g., see Table 2.1. knitr::kable( head(iris, 20), caption = &#39;Here is a nice table!&#39;, booktabs = TRUE ) Table 2.1: Here is a nice table! Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5.0 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa 5.4 3.7 1.5 0.2 setosa 4.8 3.4 1.6 0.2 setosa 4.8 3.0 1.4 0.1 setosa 4.3 3.0 1.1 0.1 setosa 5.8 4.0 1.2 0.2 setosa 5.7 4.4 1.5 0.4 setosa 5.4 3.9 1.3 0.4 setosa 5.1 3.5 1.4 0.3 setosa 5.7 3.8 1.7 0.3 setosa 5.1 3.8 1.5 0.3 setosa You can write citations, too. For example, we are using the bookdown package (Xie 2020) in this sample book, which was built on top of R Markdown and knitr (Xie 2015). "],["abundance-test.html", "Chapter 3 Abundance - test 3.1 Lincoln-Peterson 3.2 Full Likelihood 3.3 Conditional Likelihood 3.4 Data Augmentation 3.5 N-Mixture Model 3.6 Spatial Capture-Recapture", " Chapter 3 Abundance - test Here is a review of existing methods. 3.1 Lincoln-Peterson 3.2 Full Likelihood 3.3 Conditional Likelihood The conditional likelihood abundance estimator proposed by Huggins (1989) and Alho (1990), which was further extended in Huggins (1991), is an extension to previous abundance estimators to account for heterogeneous capture probabilities (\\(p\\)). The model estimates individual capture probabilities and abundance conditional on captured individuals. 3.3.1 Algebra \\[ \\mathcal{L} = \\prod_{i=1}^n \\prod_{t=1}^t p_{i,t}^{z_{i,t}}(1-p_{i,t})^{1-z_{i,t}} \\] where, \\(z_{i,t}\\) takes the value of 1 if individual \\(i\\) has been captured before occasion \\(t\\) and 0 otherwise. Thus the capture history \\(y_{i,t}\\) is used to estimate the capture probability of individual \\(i\\) as a Bernoulli trial, \\[y_{i,t} \\sim Bernoulli(p_{i,t}) \\] and abundance \\(\\hat{N}\\) is derived condtional on the count of known individuals (\\(C\\)), sometimes referred to the minimum number of known alive (\\(MNKA\\)). \\[\\hat{N} = \\frac{C}{1-\\prod^{t}(1-p_t)}\\] Variation in detection probability can be modeled using linear logistic models or other variations used to estimate probabilities 0-1. 3.3.2 Simulation N &lt;- 150 #True population size n_occ &lt;- 4 #Number of trapping occasions p &lt;- 0.50 #Probability of first detection true_detections &lt;- array(NA, dim=c(N,n_occ)) for (t in 1:n_occ){ true_detections[,t] &lt;- rbinom(n=N,size=1,prob=p) } observed &lt;- true_detections[apply(true_detections,1,max) == 1,] MNKA &lt;- nrow(observed) print( paste0(&quot;Number ever detected: &quot;, MNKA,sep = &quot; &quot;) ) #number ever detected ## [1] &quot;Number ever detected: 137 &quot; 3.3.3 Models JAGS Stan Greta JAGS model fit library(knitr) library(R2jags) data &lt;- list( y=observed, n_sites=nrow(observed), MNKA=MNKA, n_occ=n_occ ) model_string &lt;- textConnection( &quot; model { # Likelihood for(i in 1:n_sites) { # Observation model for(j in 1:n_occ) { y[i, j] ~ dbern(p) } } for(t in 1:n_occ){ p_un[t] &lt;- (1-p) } # Priors p ~ dunif(0, 1) # Uninformative prior # Derived values N &lt;- (MNKA / (1-prod(p_un[]))) }&quot;) parameters &lt;- c(&quot;p&quot;,&quot;N&quot;) inits &lt;- function() { list( ) } ni &lt;- 10000 ; nt &lt;- 1 ; nb &lt;- 5000 ; nc &lt;- 3 model &lt;- jags(data, inits, parameters, model_string, n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb) Stan model fit library(knitr) library(rstan) data &lt;- list( y=observed, nsites=nrow(observed), MNKA=MNKA, n_occ=n_occ ) stan_model &lt;- &quot; data { int&lt;lower=0&gt; MNKA; int&lt;lower=0&gt; nsites; int&lt;lower=0&gt; n_occ; int&lt;lower=0,upper=1&gt; y[MNKA, n_occ]; } parameters { real&lt;lower=0, upper=1&gt; p; } model { for(i in 1:nsites) for(j in 1:4) y[i, j] ~ bernoulli(p); } generated quantities { real N = MNKA / (1-(1-p)^4); } &quot; nc &lt;- 4 stan.samples &lt;- stan(model_code = stan_model, data = data, iter = 10000, chains = nc, cores = nc, open_progress=FALSE) Greta model fit library(reticulate) reticulate::use_condaenv(&quot;r-reticulate&quot;) reticulate::py_config() library(greta) #capture_vec &lt;- unlist(observed) p_greta &lt;- beta(1, 1) # likelihood capture_vec &lt;- as_data(observed) distribution(capture_vec) &lt;- bernoulli(p_greta) # derived parameter pstar &lt;- 1-(1-p_greta)*(1-p_greta)*(1-p_greta)*(1-p_greta) N_hat &lt;- MNKA / pstar # defining the model m &lt;- model(p_greta, N_hat, pstar) # sampling draws &lt;- greta::mcmc(m, n_samples = 1000) plot(m) 3.3.4 Comparison html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #nzxhjvvfvv .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #nzxhjvvfvv .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #nzxhjvvfvv .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #nzxhjvvfvv .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 4px; border-top-color: #FFFFFF; border-top-width: 0; } #nzxhjvvfvv .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #nzxhjvvfvv .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #nzxhjvvfvv .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #nzxhjvvfvv .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #nzxhjvvfvv .gt_column_spanner_outer:first-child { padding-left: 0; } #nzxhjvvfvv .gt_column_spanner_outer:last-child { padding-right: 0; } #nzxhjvvfvv .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; overflow-x: hidden; display: inline-block; width: 100%; } #nzxhjvvfvv .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #nzxhjvvfvv .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #nzxhjvvfvv .gt_from_md > :first-child { margin-top: 0; } #nzxhjvvfvv .gt_from_md > :last-child { margin-bottom: 0; } #nzxhjvvfvv .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #nzxhjvvfvv .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #nzxhjvvfvv .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #nzxhjvvfvv .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #nzxhjvvfvv .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #nzxhjvvfvv .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #nzxhjvvfvv .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #nzxhjvvfvv .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #nzxhjvvfvv .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #nzxhjvvfvv .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #nzxhjvvfvv .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #nzxhjvvfvv .gt_sourcenote { font-size: 90%; padding: 4px; } #nzxhjvvfvv .gt_left { text-align: left; } #nzxhjvvfvv .gt_center { text-align: center; } #nzxhjvvfvv .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #nzxhjvvfvv .gt_font_normal { font-weight: normal; } #nzxhjvvfvv .gt_font_bold { font-weight: bold; } #nzxhjvvfvv .gt_font_italic { font-style: italic; } #nzxhjvvfvv .gt_super { font-size: 65%; } #nzxhjvvfvv .gt_footnote_marks { font-style: italic; font-size: 65%; } Estimate Comparison Comparison of Huggins abundance (N) and detection probability (p) estimates fit using JAGS, Stan, greta. Mean SD LCL UCL N 150.00 NA NA NA 149.73 1.46 147.21 152.95 149.73 1.43 147.25 152.79 149.73 1.44 147.22 152.96 p NA NA NA NA 0.52 0.02 0.48 0.57 0.52 0.02 0.48 0.57 0.52 0.02 0.48 0.57 3.4 Data Augmentation 3.5 N-Mixture Model 3.6 Spatial Capture-Recapture "],["occupancy.html", "Chapter 4 Occupancy", " Chapter 4 Occupancy We describe our methods in this chapter. "],["survival.html", "Chapter 5 Survival 5.1 Individual-level Cormack-Jolly-Seber 5.2 Model Name 5.3 Jolly-Seber", " Chapter 5 Survival 5.1 Individual-level Cormack-Jolly-Seber 5.2 Model Name Model description 5.2.1 Algebra Algebraic model description in latex 5.2.2 Simulation n_occ &lt;- 4 # Number of capture occasions marked &lt;- rep(50, n_occ-1) # Annual number of newly marked individuals phi &lt;- rep(0.65, n_occ-1) p &lt;- rep(0.4, n_occ-1) # Define matrices with survival and recapture probabilities PHI &lt;- matrix(phi, ncol = n_occ-1, nrow = sum(marked)) P &lt;- matrix(p, ncol = n_occ-1, nrow = sum(marked)) CH &lt;- matrix(0, ncol = n_occ, nrow = sum(marked)) marking_occ &lt;- rep(1:length(marked), marked[1:length(marked)]) # Fill the CH matrix i&lt;-1 for (i in 1:sum(marked)){ CH[i, marking_occ[i]] &lt;- 1 # Write an 1 at the release occasion if (marking_occ[i]==n_occ) next for (t in (marking_occ[i]+1):n_occ){ survive_occasion &lt;- rbinom(1, 1, PHI[i,t-1]) if (survive_occasion==0) break rp &lt;- rbinom(1, 1, P[i,t-1]) if (rp==1) CH[i,t] &lt;- 1 } #t } #i get.first.capture &lt;- function(x) min(which(x!=0)) first_capture &lt;- apply(CH, 1, get.first.capture) get.last.capture &lt;- function(x) max(which(x!=0)) last_capture &lt;- apply(CH, 1, get.last.capture) 5.2.3 Models JAGS Stan Greta JAGS model fit library(knitr) library(R2jags) data &lt;- list( y = CH, n_ind = dim(CH)[1], nocc = dim(CH)[2], f = first_capture ) model_string &lt;- textConnection( &quot; model { # Likelihood for (i in 1:n_ind){ z[i,f[i]] &lt;- 1 for (t in (f[i]+1):nocc){ # State process z[i,t] ~ dbern(mu_phi * z[i,t-1])#[i,t-1] # Observation process y[i,t] ~ dbern(mu[i,t]) mu[i,t] &lt;- mu_p * z[i,t]#[i,t-1] } #t } #i # Priors and Constraints # for (i in 1:n_ind){ # for (t in f[i]:(n_occ-1)){ # phi[i,t] &lt;- mu_phi # p[i,t] &lt;- mu_p # } #t # } #i mu_phi ~ dunif(0, 1) mu_p ~ dunif(0, 1) # Derived values } &quot; ) parameters &lt;- c(&quot;mu_p&quot;,&quot;mu_phi&quot;) cjs.z.init &lt;- function(ch){ state &lt;- ch for (i in 1:dim(ch)[1]){ n1 &lt;- min(which(ch[i,]==1)) n2 &lt;- max(which(ch[i,]==1)) state[i,n1:n2] &lt;- 1 state[i,n1] &lt;- NA } state[state==0] &lt;- NA return(state) } set_initial_value &lt;- function() { list( z = cjs.z.init(CH) ) } ni &lt;- 10000 ; nt &lt;- 1 ; nb &lt;- 5000 ; nc &lt;- 3 model &lt;- jags(data, set_initial_value, parameters, model_string, n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb) Stan library(knitr) library(rstan) data &lt;- list( CH = CH, n_ind = dim(CH)[1], n_occ = dim(CH)[2] # f = first_capture, # l = last_capture ) stan_model &lt;- &quot; /** * Cormack-Jolly-Seber Model * * following section 1.2.1 of: * http://www.maths.otago.ac.nz/home/resources/theses/PhD_Matthew_Schofield.pdf * https://discourse.mc-stan.org/t/cjs-log-likelihood/15112 */ data { int&lt;lower=2&gt; n_occ; // capture events int&lt;lower=0&gt; n_ind; // number of individuals int&lt;lower=0,upper=1&gt; CH[n_ind,n_occ]; // CH[i,k]: individual i captured at k } transformed data { int&lt;lower=0,upper=n_occ+1&gt; first[n_ind]; // first[i]: ind i first capture int&lt;lower=0,upper=n_occ+1&gt; last[n_ind]; // last[i]: ind i last capture int&lt;lower=0,upper=n_ind&gt; n_captured[n_occ]; // n_capt[k]: num aptured at k first = rep_array(n_occ+1,n_ind); last = rep_array(0,n_ind); for (i in 1:n_ind) { for (k in 1:n_occ) { if (CH[i,k] == 1) { if (k &lt; first[i]) first[i] = k; if (k &gt; last[i]) last[i] = k; } } } n_captured = rep_array(0,n_occ); for (i in 1:n_ind) for (k in 1:n_occ) n_captured[k] = n_captured[k] + CH[i,k]; } parameters { //vector&lt;lower=0,upper=1&gt;[n_occ-1] phi; // phi[k]: Pr[alive at k + 1 | alive at k] //vector&lt;lower=0,upper=1&gt;[n_occ] p; // p[k]: Pr[capture at k] real&lt;lower=0,upper=1&gt; phi; // phi[k]: Pr[alive at k + 1 | alive at k] real&lt;lower=0,upper=1&gt; p; // p[k]: Pr[capture at k] // note: p[1] not used in model and hence not identified } transformed parameters { vector&lt;lower=0,upper=1&gt;[n_occ] chi; // chi[k]: Pr[no capture &gt; k | alive at k] vector[n_ind] log_lik; { int k; chi[n_occ] = 1.0; k = n_occ - 1; while (k &gt; 0) { //chi[k] = (1 - phi[k]) + phi[k] * (1 - p[k+1]) * chi[k+1]; chi[k] = (1 - phi) + phi * (1 - p) * chi[k+1]; k = k - 1; } } for (i in 1:n_ind) { log_lik[i] = 0; if (last[i] &gt; 0) { for (k in (first[i]+1):last[i]) { log_lik[i] +=log(phi); // i survived from k-1 to k if (CH[i,k] == 1) log_lik[i] +=log(p); // i captured at k else log_lik[i] +=log1m(p); // i not captured at k } log_lik[i] +=log(chi[last[i]]); // i not seen after last[i] } } } model { target += sum(log_lik); } generated quantities { // phi[K-1] and p(K) not identified, but product is real beta; vector&lt;lower=0&gt;[n_occ] pop_hat; // population beta = phi * p; for (k in 1:n_occ) pop_hat[k] = n_captured[k] / p; } &quot; inits &lt;- function() list(phi = runif(1, 0, 1), p = runif(1, 0, 1)) ## Parameters monitored params &lt;- c(&quot;phi&quot;, &quot;p&quot;) ## MCMC settings ni &lt;- 2000 nt &lt;- 1 nb &lt;- 1000 nc &lt;- 4 stan.samples &lt;- stan(model_code = stan_model, data = data, iter = 10000, chains = nc, cores = nc) library(knitr) library(rstan) data &lt;- list( CH = CH, n_ind = dim(CH)[1], n_occ = dim(CH)[2], f = first_capture, l = last_capture ) stan_model &lt;- &quot; /** * Cormack-Jolly-Seber Model * * following section 1.2.1 of: * http://www.maths.otago.ac.nz/home/resources/theses/PhD_Matthew_Schofield.pdf * https://discourse.mc-stan.org/t/cjs-log-likelihood/15112 */ data { int&lt;lower=2&gt; n_occ; // capture events int&lt;lower=0&gt; n_ind; // number of individuals int&lt;lower=0, upper=n_occ+1&gt; f[n_ind]; // f[i]: ind i first capture int&lt;lower=0, upper=n_occ+1&gt; l[n_ind]; // l[i]: ind i last capture int&lt;lower=0,upper=1&gt; CH[n_ind,n_occ]; // CH[i,k]: individual i captured at k } transformed data { int&lt;lower=0,upper=n_ind&gt; n_captured[n_occ]; // n_capt[k]: num aptured at k n_captured = rep_array(0,n_occ); for (i in 1:n_ind) for (k in 1:n_occ) n_captured[k] = n_captured[k] + CH[i,k]; } parameters { //vector&lt;lower=0,upper=1&gt;[n_occ-1] phi; // phi[k]: Pr[alive at k + 1 | alive at k] //vector&lt;lower=0,upper=1&gt;[n_occ] p; // p[k]: Pr[capture at k] real&lt;lower=0,upper=1&gt; phi; // phi[k]: Pr[alive at k + 1 | alive at k] real&lt;lower=0,upper=1&gt; p; // p[k]: Pr[capture at k] // note: p[1] not used in model and hence not identified } transformed parameters { vector&lt;lower=0,upper=1&gt;[n_occ] chi; // chi[k]: Pr[no capture &gt; k | alive at k] vector[n_ind] log_lik; { int k; chi[n_occ] = 1.0; k = n_occ - 1; while (k &gt; 0) { //chi[k] = (1 - phi[k]) + phi[k] * (1 - p[k+1]) * chi[k+1]; chi[k] = (1 - phi) + phi * (1 - p) * chi[k+1]; k = k - 1; } } for (i in 1:n_ind) { log_lik[i] = 0; if (l[i] &gt; 0) { for (k in (f[i]+1):l[i]) { log_lik[i] +=log(phi); // i survived from k-1 to k if (CH[i,k] == 1) log_lik[i] +=log(p); // i captured at k else log_lik[i] +=log1m(p); // i not captured at k } log_lik[i] +=log(chi[l[i]]); // i not seen after last[i] } } } model { target += sum(log_lik); } generated quantities { // phi[K-1] and p(K) not identified, but product is real beta; vector&lt;lower=0&gt;[n_occ] pop_hat; // population beta = phi * p; for (k in 1:n_occ) pop_hat[k] = n_captured[k] / p; } &quot; inits &lt;- function() list(phi = runif(1, 0, 1), p = runif(1, 0, 1)) ## Parameters monitored params &lt;- c(&quot;phi&quot;, &quot;p&quot;) ## MCMC settings ni &lt;- 2000 nt &lt;- 1 nb &lt;- 1000 nc &lt;- 4 stan.samples &lt;- stan(model_code = stan_model, data = data, iter = 10000, chains = nc, cores = nc) Greta library(greta) head(CH) head(obs_id) head(capture_vec) obs_id &lt;- apply(CH, 1, function(x) seq(min(which(x &gt; 0)), max(which(x &gt; 0)), by = 1)[-1]) obs_id &lt;- unlist(obs_id) capture_vec &lt;- apply(CH, 1, function(x) x[min(which(x &gt; 0)):max(which(x &gt; 0))][-1]) capture_vec &lt;- unlist(capture_vec) # dummy variables alive_data &lt;- ones(length(obs_id)) # definitely alive not_seen_last &lt;- last_capture != n_occ # ignore observations in last timestep final_observation &lt;- ones(sum(not_seen_last)) # final observation capture_vec &lt;- as_data(observed) # priors phi &lt;- beta(1, 1, dim = 1) p &lt;- beta(1, 1, dim = 1) # derived parameter chi &lt;- ones(n_occ) for (i in seq_len(n_occ - 1)) { tn &lt;- n_occ - i chi[tn] &lt;- (1 - phi) + phi * (1 - p) * chi[tn + 1] } # likelihood distribution(alive_data) &lt;- bernoulli(phi) distribution(capture_vec) &lt;- bernoulli(p) distribution(final_observation) &lt;- bernoulli(chi[last_capture[not_seen_last]]) # defining the model m &lt;- model(phi,p) #objects to sample # sampling draws &lt;- greta::mcmc(m, n_samples = 1000) plot(m) 5.2.4 Comparison html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #xwycfaqsme .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #xwycfaqsme .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #xwycfaqsme .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #xwycfaqsme .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 4px; border-top-color: #FFFFFF; border-top-width: 0; } #xwycfaqsme .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #xwycfaqsme .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #xwycfaqsme .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #xwycfaqsme .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #xwycfaqsme .gt_column_spanner_outer:first-child { padding-left: 0; } #xwycfaqsme .gt_column_spanner_outer:last-child { padding-right: 0; } #xwycfaqsme .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; overflow-x: hidden; display: inline-block; width: 100%; } #xwycfaqsme .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #xwycfaqsme .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #xwycfaqsme .gt_from_md > :first-child { margin-top: 0; } #xwycfaqsme .gt_from_md > :last-child { margin-bottom: 0; } #xwycfaqsme .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #xwycfaqsme .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #xwycfaqsme .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #xwycfaqsme .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #xwycfaqsme .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #xwycfaqsme .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #xwycfaqsme .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #xwycfaqsme .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #xwycfaqsme .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #xwycfaqsme .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #xwycfaqsme .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #xwycfaqsme .gt_sourcenote { font-size: 90%; padding: 4px; } #xwycfaqsme .gt_left { text-align: left; } #xwycfaqsme .gt_center { text-align: center; } #xwycfaqsme .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #xwycfaqsme .gt_font_normal { font-weight: normal; } #xwycfaqsme .gt_font_bold { font-weight: bold; } #xwycfaqsme .gt_font_italic { font-style: italic; } #xwycfaqsme .gt_super { font-size: 65%; } #xwycfaqsme .gt_footnote_marks { font-style: italic; font-size: 65%; } Estimate Comparison Comparison of C-J-S apparent survival (phi) and recapture probability (p) estimates fit using JAGS, Stan, greta. Mean SD LCL UCL phi 0.65 NA NA NA 0.60 0.08 0.47 0.78 0.61 0.08 0.46 0.78 0.62 0.07 0.49 0.78 p 0.40 NA NA NA 0.44 0.08 0.29 0.60 0.43 0.08 0.28 0.60 0.46 0.07 0.32 0.61 5.3 Jolly-Seber "],["appendix-a.html", "A Appendix A A.1 Authors Guidelines", " A Appendix A A.1 Authors Guidelines We have decided to adapt the tidyverse style guide. Detailed content can be found here. tidyverse style guide Before committing code to the git repository, it should be styled using the styler package. Primary points are outlined below: - Use underscores to separate words in both variable and file names. File Names: chapter_1.Rmd --- Variable Names: observed_data When submitting a description of a new model use the template provided in Appendix B. However, if extenuating circumstances make the template in Appendix B untenable for a model, describe the reason for departure in the git commit message. Variables should be named with nouns, functions should be named with verbs Use dots to separate words in function names simulate.code &lt;- function(X) { } Label function arguments Spaces after commas not before Do not pad parentheses with spaces Pad operators with space foo == bar foo &lt;- bar foo + bar foo * bar "],["appendix-b.html", "B Appendix B B.1 Model Template", " B Appendix B B.1 Model Template ## Model Name Model description ### Algebra Algebraic model description in latex ### Simulation ```{r }r &#39;&#39;` simulated_data &lt;- 1 ``` ### Models {.tabset} ::: {.tab} &lt;button class=&quot;tablinks&quot; onclick=&quot;unrolltab(event,&#39;JAGS&#39;)&quot;&gt;JAGS&lt;/button&gt; &lt;button class=&quot;tablinks&quot; onclick=&quot;unrolltab(event, &#39;Stan&#39;)&quot;&gt;Stan&lt;/button&gt; &lt;button class=&quot;tablinks&quot; onclick=&quot;unrolltab(event, &#39;Greta&#39;)&quot;&gt;Greta&lt;/button&gt; ::: {#JAGS .tabcontent} #### JAGS model fit {-} ```{r,warning=FALSE,message=FALSE,error=FALSE, results=&#39;hide&#39;,cache = TRUE}r &#39;&#39;` library(knitr) library(R2jags) data &lt;- list( ) model_string &lt;- textConnection( &quot; model { # Likelihood # Priors # Derived values } &quot; ) parameters &lt;- c( ) set_initial_value &lt;- function() { list( ) } ni &lt;- 10000 ; nt &lt;- 1 ; nb &lt;- 5000 ; nc &lt;- 3 model &lt;- jags(data, set_initial_value, parameters, model_string, n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb) ``` ::: ::: {#Stan .tabcontent} #### Stan {-} ```{r ,warning=FALSE,message=FALSE,error=FALSE, results=&#39;hide&#39;,cache = TRUE}r &#39;&#39;` library(knitr) library(rstan) data &lt;- list( ) stan_model &lt;- &quot; data { } parameters { } model { } generated quantities { } &quot; nc &lt;- 4 stan.samples &lt;- stan(model_code = stan_model, data = data, iter = 10000, chains = nc, cores = nc) ``` ::: ::: {#Greta .tabcontent} #### Greta {-} ```{r}r &#39;&#39;` library(greta) # priors # likelihood # derived parameter # defining the model m &lt;- model() #objects to sample # sampling draws &lt;- greta::mcmc(m, n_samples = 1000) ``` ```{r}r &#39;&#39;` plot(m) ``` ::: ::: ### Comparison ```{r , echo=FALSE, warning=FALSE}r``` #round(model$BUGSoutput$summary[c(1,3),c(1,2,3,7)],2) #jags #round(summary(stan.samples)$summary[c(2,1),c(1,3,4,8)],2) #stan #summary(draws) #greta #https://gt.rstudio.com/articles/intro-creating-gt-tables.html library(gt) library(tidyverse) results_df &lt;- data.frame( Sampler=c(), Parameter=c(), Mean=c(), SD=c(), LCL=c(), UCL=c() ) results_df %&gt;% dplyr::select(-Sampler,-Parameter) %&gt;% gt() %&gt;% tab_row_group( group = &quot;p&quot;, rows = 5:8 ) %&gt;% tab_row_group( group = &quot;N&quot;, rows = 1:4 ) %&gt;% tab_header( title = &quot;&quot;, subtitle = &quot;&quot; ) ``` "],["references.html", "References", " References Alho, J. M. 1990. Logistic Regression in CaptureRecapture Models. Biometrics 46 (3): 62335. Huggins, R. M. 1989. On the Statistical Analysis of Capture Experiments. Biometrika 76 (1): 13340. https://doi.org/10.2307/2336377. . 1991. Some Practical Aspects of a Conditional Likelihood Approach to Capture Experiments. Biometrics 47 (2): 72532. https://doi.org/10.2307/2532158. Xie, Yihui. 2015. Dynamic Documents with R and Knitr. 2nd ed. Boca Raton, Florida: Chapman; Hall/CRC. http://yihui.org/knitr/. . 2020. Bookdown: Authoring Books and Technical Documents with r Markdown. https://github.com/rstudio/bookdown. "]]
