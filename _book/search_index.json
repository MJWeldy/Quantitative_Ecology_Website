[["index.html", "Quantitative Ecology Modelling applications in population ecology Chapter 1 Prerequisites", " Quantitative Ecology Modelling applications in population ecology Matt Weldy 2021-03-18 Chapter 1 Prerequisites This is a work in progress. The scope of this work is to demonstrate the fit of well known ecological models using a variety of tools. Our aim is to provide brief model descriptions, primary citations, and a simple simulation and model fit. Contributions to this web page are welcome, and can be made through the books github repository. The website is hosted through netlify, which offers continuous integration with the books git repository. Commit changes to the repository after using the bookdown and changes will populate to the page. Please try to structure indivudal model fits using the template outlined in Appendix B. bookdown::render_book(&quot;index.Rmd&quot;, &quot;bookdown::gitbook&quot;) "],["intro.html", "Chapter 2 Introduction 2.1 Probabilistic Modelling in Ecology 2.2 Common Distributions 2.3 Linear Models 2.4 Common Priors", " Chapter 2 Introduction 2.1 Probabilistic Modelling in Ecology 2.2 Common Distributions 2.3 Linear Models 2.4 Common Priors "],["abundance.html", "Chapter 3 Abundance 3.1 Lincoln-Peterson 3.2 Full Likelihood 3.3 Conditional Likelihood 3.4 Data Augmentation 3.5 N-Mixture Model 3.6 Spatial Capture-Recapture", " Chapter 3 Abundance Here is a review of existing methods. 3.1 Lincoln-Peterson 3.2 Full Likelihood 3.3 Conditional Likelihood The conditional likelihood abundance estimator proposed by Huggins (1989) and Alho (1990), which was further extended in Huggins (1991), is an extension to previous abundance estimators to account for heterogeneous capture probabilities (\\(p\\)). The model estimates individual capture probabilities and abundance conditional on captured individuals. 3.3.1 Algebra The capture history \\(y_{i,t}\\) is used to estimate the capture probability of individual \\(i\\) as a Bernoulli trial, \\[y_{i,t} \\sim Bernoulli(p_{i,t}) \\] \\[\\mathcal{L}(p| y) = \\prod_{i=1}^n \\prod_{t=1}^t p_{i,t}^{z_{i,t}}(1-p_{i,t})^{1-z_{i,t}}\\] Abundance \\(\\hat{N}\\) is derived conditional on the count of known individuals (\\(C\\)), sometimes referred to the minimum number of known alive (\\(MNKA\\)). \\[\\hat{N} = \\frac{C}{1-\\prod^{t}(1-p_t)}\\] Variation in detection probability can be modeled using linear logistic models or other variations used to estimate probabilities 0-1. 3.3.2 Simulation set.seed(1) N &lt;- 150 #True population size n_occ &lt;- 4 #Number of trapping occasions p &lt;- 0.50 #Probability of first detection true_detections &lt;- array(NA, dim=c(N,n_occ)) for (t in 1:n_occ){ true_detections[,t] &lt;- rbinom(n=N,size=1,prob=p) } observed &lt;- true_detections[apply(true_detections,1,max) == 1,] MNKA &lt;- nrow(observed) print( paste0(&quot;Number ever detected: &quot;, MNKA,sep = &quot; &quot;) ) #number ever detected ## [1] &quot;Number ever detected: 139 &quot; 3.3.3 Models JAGS NIMBLE Stan Greta JAGS model fit library(R2jags) data &lt;- list( y=observed, n_sites=nrow(observed), MNKA=MNKA, n_occ=n_occ ) model_string &lt;- textConnection( &quot; model { # Likelihood for(i in 1:n_sites) { # Observation model for(j in 1:n_occ) { y[i, j] ~ dbern(p) } } for(t in 1:n_occ){ p_un[t] &lt;- (1-p) } # Priors p ~ dunif(0, 1) # Uninformative prior # Derived values N &lt;- (MNKA / (1-prod(p_un[]))) }&quot;) parameters &lt;- c(&quot;p&quot;,&quot;N&quot;) inits &lt;- function() { list( ) } ni &lt;- 10000 ; nt &lt;- 1 ; nb &lt;- 5000 ; nc &lt;- 3 model &lt;- jags(data, inits, parameters, model_string, n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb) NIMBLE model fit library(nimble) n_data &lt;- list( y = observed, MNKA = MNKA ) n_constants &lt;- list( n_occ = n_occ ) Nimble_Code &lt;- nimbleCode({ # Likelihood for(i in 1:MNKA) { # Observation model for(j in 1:n_occ) { y[i, j] ~ dbern(p) } #j } #i # Priors p ~ dunif(0, 1) # Uninformative prior # Derived values for(t in 1:n_occ){ p_un[t] &lt;- (1-p) } #t N &lt;- (MNKA / (1-prod(p_un[1:n_occ]))) #The only difference in this model is here declaring dimensions }) n_params &lt;- c(&quot;p&quot;, &quot;N&quot;) n_inits &lt;- list( ) Nimble_Model &lt;- nimbleModel( code = Nimble_Code, constants = n_constants, data = n_data, inits = n_inits ) MCMC_Model &lt;- configureMCMC(Nimble_Model, monitors = n_params, print = T, enableWAIC = F) Model1_MCMC &lt;- buildMCMC(MCMC_Model) Comp_Model &lt;- compileNimble( Nimble_Model, showCompilerOutput = TRUE ) Comp_Model &lt;- compileNimble(Model1_MCMC, project = Nimble_Model) niter=10000 Model_samples &lt;- runMCMC(Comp_Model, niter = niter, nburnin=niter/2,nchains=3,summary = TRUE) #mcmc_combo(Model_samples$samples, pars = c(&quot;N&quot;, &quot;p&quot;)) round(Model_samples$summary$all.chains,2) Stan model fit library(knitr) library(rstan) data &lt;- list( y=observed, nsites=nrow(observed), MNKA=MNKA, n_occ=n_occ ) stan_model &lt;- &quot; data { int&lt;lower=0&gt; MNKA; int&lt;lower=0&gt; nsites; int&lt;lower=0&gt; n_occ; int&lt;lower=0,upper=1&gt; y[MNKA, n_occ]; } parameters { real&lt;lower=0, upper=1&gt; p; } model { for(i in 1:nsites) for(j in 1:4) target += bernoulli_lpmf(y[i, j] | p); } generated quantities { real pstar = (1-(1-p)^n_occ); real N = MNKA / pstar; } &quot; nc &lt;- 4 stan.samples &lt;- stan(model_code = stan_model, data = data, iter = 10000, chains = nc, cores = nc, open_progress=FALSE) Greta model fit library(reticulate) reticulate::use_condaenv(&quot;r-reticulate&quot;) reticulate::py_config() library(greta) capture_vec &lt;- unlist(observed) # priors p_greta &lt;- beta(1, 1) # likelihood distribution(capture_vec) &lt;- bernoulli(p_greta) # derived parameters pstar &lt;- 1 - (1 - p_greta)^n_occ N_hat &lt;- MNKA / pstar # defining the model m &lt;- model(p_greta, N_hat, pstar) # sampling draws &lt;- greta::mcmc(m, n_samples = 1000) plot(m) 3.3.4 Comparison html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #sebuelczrn .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #sebuelczrn .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #sebuelczrn .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #sebuelczrn .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 4px; border-top-color: #FFFFFF; border-top-width: 0; } #sebuelczrn .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #sebuelczrn .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #sebuelczrn .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #sebuelczrn .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #sebuelczrn .gt_column_spanner_outer:first-child { padding-left: 0; } #sebuelczrn .gt_column_spanner_outer:last-child { padding-right: 0; } #sebuelczrn .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; overflow-x: hidden; display: inline-block; width: 100%; } #sebuelczrn .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #sebuelczrn .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #sebuelczrn .gt_from_md > :first-child { margin-top: 0; } #sebuelczrn .gt_from_md > :last-child { margin-bottom: 0; } #sebuelczrn .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #sebuelczrn .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #sebuelczrn .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #sebuelczrn .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #sebuelczrn .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #sebuelczrn .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #sebuelczrn .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #sebuelczrn .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #sebuelczrn .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #sebuelczrn .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #sebuelczrn .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #sebuelczrn .gt_sourcenote { font-size: 90%; padding: 4px; } #sebuelczrn .gt_left { text-align: left; } #sebuelczrn .gt_center { text-align: center; } #sebuelczrn .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #sebuelczrn .gt_font_normal { font-weight: normal; } #sebuelczrn .gt_font_bold { font-weight: bold; } #sebuelczrn .gt_font_italic { font-style: italic; } #sebuelczrn .gt_super { font-size: 65%; } #sebuelczrn .gt_footnote_marks { font-style: italic; font-size: 65%; } Estimate Comparison Comparison of Huggins abundance (N) and detection probability (p) estimates fit using JAGS, Stan, greta. Mean SD LCL UCL N 150.00 NA NA NA 149.73 1.46 147.21 152.95 149.73 1.46 147.21 152.95 149.73 1.43 147.25 152.79 p 149.73 1.44 147.22 152.96 NA NA NA NA 0.52 0.02 0.48 0.57 0.52 0.02 0.48 0.57 0.52 0.02 0.48 0.57 0.52 0.02 0.48 0.57 3.4 Data Augmentation 3.5 N-Mixture Model 3.6 Spatial Capture-Recapture "],["occupancy.html", "Chapter 4 Occupancy", " Chapter 4 Occupancy We describe our methods in this chapter. "],["survival.html", "Chapter 5 Survival 5.1 Individual-level Cormack-Jolly-Seber 5.2 Jolly-Seber", " Chapter 5 Survival 5.1 Individual-level Cormack-Jolly-Seber Model description 5.1.1 Algebra Log likelihood of the state-space parametrization \\[\\mathcal{L}(\\phi, p, z| y) = f(z_1|\\phi) \\prod_{t=2}^T f(z_t| z_{t-1}, \\phi) \\prod_{t=1}^T f(y_t| z_t, p)\\] State Process \\[z_{i_f} = 1\\] \\[z_{i,t+1}|z_{i,t} \\sim Bernoulli(z_{i,t} \\phi_{i,t}) \\] Observation Process \\[y_{i,t}|z_{i,t} \\sim Bernoulli(z_{i,t},p_{i,t})\\] 5.1.2 Simulation n_occ &lt;- 4 # Number of capture occasions marked &lt;- rep(50, n_occ-1) # Annual number of newly marked individuals phi &lt;- rep(0.65, n_occ-1) p &lt;- rep(0.4, n_occ-1) # Define matrices with survival and recapture probabilities PHI &lt;- matrix(phi, ncol = n_occ-1, nrow = sum(marked)) P &lt;- matrix(p, ncol = n_occ-1, nrow = sum(marked)) CH &lt;- matrix(0, ncol = n_occ, nrow = sum(marked)) marking_occ &lt;- rep(1:length(marked), marked[1:length(marked)]) # Fill the CH matrix i&lt;-1 for (i in 1:sum(marked)){ CH[i, marking_occ[i]] &lt;- 1 # Write an 1 at the release occasion if (marking_occ[i]==n_occ) next for (t in (marking_occ[i]+1):n_occ){ survive_occasion &lt;- rbinom(1, 1, PHI[i,t-1]) if (survive_occasion==0) break rp &lt;- rbinom(1, 1, P[i,t-1]) if (rp==1) CH[i,t] &lt;- 1 } #t } #i get.first.capture &lt;- function(x) min(which(x!=0)) first_capture &lt;- apply(CH, 1, get.first.capture) get.last.capture &lt;- function(x) max(which(x!=0)) last_capture &lt;- apply(CH, 1, get.last.capture) 5.1.3 Models JAGS NIMBLE Stan Greta JAGS model fit library(knitr) library(R2jags) data &lt;- list( y = CH, n_ind = dim(CH)[1], nocc = dim(CH)[2], f = first_capture ) model_string &lt;- textConnection( &quot; model { # Likelihood for (i in 1:n_ind){ z[i,f[i]] &lt;- 1 for (t in (f[i]+1):n_occ){ # State process z[i,t] ~ dbern(phi * z[i,t-1]) # Observation process y[i,t] ~ dbern(mu[i,t]) mu[i,t] &lt;- p * z[i,t] } #t } #i # Priors and Constraints phi ~ dunif(0, 1) p ~ dunif(0, 1) # Derived values } &quot; ) parameters &lt;- c(&quot;p&quot;,&quot;phi&quot;) cjs.z.init &lt;- function(ch){ state &lt;- ch for (i in 1:dim(ch)[1]){ n1 &lt;- min(which(ch[i,]==1)) n2 &lt;- max(which(ch[i,]==1)) state[i,n1:n2] &lt;- 1 state[i,n1] &lt;- NA } state[state==0] &lt;- NA return(state) } set_initial_value &lt;- function() { list( z = cjs.z.init(CH) ) } ni &lt;- 10000 ; nt &lt;- 1 ; nb &lt;- 5000 ; nc &lt;- 3 model &lt;- jags(data, set_initial_value, parameters, model_string, n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb) NIMBLE model fit library(nimble) n_data &lt;- list( y = CH ) n_constants &lt;- list( n_ind = dim(CH)[1], nocc = dim(CH)[2], f = first_capture ) Nimble_Code &lt;- nimbleCode({ # Likelihood for (i in 1:n_ind){ z[i,f[i]] &lt;- 1 for (t in (f[i]+1):n_occ){ # State process z[i,t] ~ dbern(phi * z[i,t-1]) # Observation process y[i,t] ~ dbern(mu[i,t]) mu[i,t] &lt;- p * z[i,t] } #t } #i # Priors and Constraints phi ~ dunif(0, 1) p ~ dunif(0, 1) # Derived values }) n_params &lt;- c(&quot;p&quot;, &quot;phi&quot;) cjs.z.init &lt;- function(ch){ state &lt;- ch for (i in 1:dim(ch)[1]){ n1 &lt;- min(which(ch[i,]==1)) n2 &lt;- max(which(ch[i,]==1)) state[i,n1:n2] &lt;- 1 state[i,n1] &lt;- NA } state[state==0] &lt;- NA return(state) } n_inits &lt;- list( z = cjs.z.init(CH) ) Nimble_Model &lt;- nimbleModel( code = Nimble_Code, constants = n_constants, data = n_data, inits = n_inits ) MCMC_Model &lt;- configureMCMC(Nimble_Model, monitors = n_params, print = T, enableWAIC = F) Model1_MCMC &lt;- buildMCMC(MCMC_Model) Comp_Model &lt;- compileNimble( Nimble_Model, showCompilerOutput = TRUE ) Comp_Model &lt;- compileNimble(Model1_MCMC, project = Nimble_Model) niter=10000 Model_samples &lt;- runMCMC(Comp_Model, niter = niter, nburnin=niter/2,nchains=3,summary = TRUE) #mcmc_combo(Model_samples$samples, pars = c(&quot;N&quot;, &quot;p&quot;)) round(Model_samples$summary$all.chains,2) Stan model fit library(knitr) library(rstan) data &lt;- list( CH = CH, n_ind = dim(CH)[1], n_occ = dim(CH)[2], f = first_capture, l = last_capture ) stan_model &lt;- &quot; /** * Cormack-Jolly-Seber Model * * following section 1.2.1 of: * http://www.maths.otago.ac.nz/home/resources/theses/PhD_Matthew_Schofield.pdf * https://discourse.mc-stan.org/t/cjs-log-likelihood/15112 */ data { int&lt;lower=2&gt; n_occ; // capture events int&lt;lower=0&gt; n_ind; // number of individuals int&lt;lower=0, upper=n_occ+1&gt; f[n_ind]; // f[i]: ind i first capture int&lt;lower=0, upper=n_occ+1&gt; l[n_ind]; // l[i]: ind i last capture int&lt;lower=0,upper=1&gt; CH[n_ind,n_occ]; // CH[i,k]: individual i captured at k } transformed data { int&lt;lower=0,upper=n_ind&gt; n_captured[n_occ]; // n_capt[k]: num aptured at k n_captured = rep_array(0,n_occ); for (i in 1:n_ind) for (k in 1:n_occ) n_captured[k] = n_captured[k] + CH[i,k]; } parameters { //vector&lt;lower=0,upper=1&gt;[n_occ-1] phi; // phi[k]: Pr[alive at k + 1 | alive at k] //vector&lt;lower=0,upper=1&gt;[n_occ] p; // p[k]: Pr[capture at k] real&lt;lower=0,upper=1&gt; phi; // phi[k]: Pr[alive at k + 1 | alive at k] real&lt;lower=0,upper=1&gt; p; // p[k]: Pr[capture at k] // note: p[1] not used in model and hence not identified } transformed parameters { vector&lt;lower=0,upper=1&gt;[n_occ] chi; // chi[k]: Pr[no capture &gt; k | alive at k] vector[n_ind] log_lik; { int k; chi[n_occ] = 1.0; k = n_occ - 1; while (k &gt; 0) { //chi[k] = (1 - phi[k]) + phi[k] * (1 - p[k+1]) * chi[k+1]; chi[k] = (1 - phi) + phi * (1 - p) * chi[k+1]; k = k - 1; } } for (i in 1:n_ind) { log_lik[i] = 0; if (l[i] &gt; 0) { for (k in (f[i]+1):l[i]) { log_lik[i] +=log(phi); // i survived from k-1 to k if (CH[i,k] == 1) log_lik[i] +=log(p); // i captured at k else log_lik[i] +=log1m(p); // i not captured at k } log_lik[i] +=log(chi[l[i]]); // i not seen after last[i] } } } model { target += sum(log_lik); } generated quantities { // phi[K-1] and p(K) not identified, but product is real beta; vector&lt;lower=0&gt;[n_occ] pop_hat; // population beta = phi * p; for (k in 1:n_occ) pop_hat[k] = n_captured[k] / p; } &quot; inits &lt;- function() list(phi = runif(1, 0, 1), p = runif(1, 0, 1)) ## Parameters monitored params &lt;- c(&quot;phi&quot;, &quot;p&quot;) ## MCMC settings ni &lt;- 2000 nt &lt;- 1 nb &lt;- 1000 nc &lt;- 4 stan.samples &lt;- stan(model_code = stan_model, data = data, iter = 10000, chains = nc, cores = nc) Greta model fit library(greta) head(CH) head(obs_id) head(capture_vec) obs_id &lt;- apply(CH, 1, function(x) seq(min(which(x &gt; 0)), max(which(x &gt; 0)), by = 1)[-1]) obs_id &lt;- unlist(obs_id) capture_vec &lt;- apply(CH, 1, function(x) x[min(which(x &gt; 0)):max(which(x &gt; 0))][-1]) capture_vec &lt;- unlist(capture_vec) # dummy variables alive_data &lt;- ones(length(obs_id)) # definitely alive not_seen_last &lt;- last_capture != n_occ # ignore observations in last timestep final_observation &lt;- ones(sum(not_seen_last)) # final observation capture_vec &lt;- as_data(observed) # priors phi &lt;- beta(1, 1, dim = 1) p &lt;- beta(1, 1, dim = 1) # derived parameter chi &lt;- ones(n_occ) for (i in seq_len(n_occ - 1)) { tn &lt;- n_occ - i chi[tn] &lt;- (1 - phi) + phi * (1 - p) * chi[tn + 1] } # likelihood distribution(alive_data) &lt;- bernoulli(phi) distribution(capture_vec) &lt;- bernoulli(p) distribution(final_observation) &lt;- bernoulli(chi[last_capture[not_seen_last]]) # defining the model m &lt;- model(phi,p) #objects to sample # sampling draws &lt;- greta::mcmc(m, n_samples = 1000) plot(m) 5.1.4 Comparison html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #xchenmscem .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #xchenmscem .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #xchenmscem .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #xchenmscem .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 4px; border-top-color: #FFFFFF; border-top-width: 0; } #xchenmscem .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #xchenmscem .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #xchenmscem .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #xchenmscem .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #xchenmscem .gt_column_spanner_outer:first-child { padding-left: 0; } #xchenmscem .gt_column_spanner_outer:last-child { padding-right: 0; } #xchenmscem .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; overflow-x: hidden; display: inline-block; width: 100%; } #xchenmscem .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #xchenmscem .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #xchenmscem .gt_from_md > :first-child { margin-top: 0; } #xchenmscem .gt_from_md > :last-child { margin-bottom: 0; } #xchenmscem .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #xchenmscem .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #xchenmscem .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #xchenmscem .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #xchenmscem .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #xchenmscem .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #xchenmscem .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #xchenmscem .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #xchenmscem .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #xchenmscem .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #xchenmscem .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #xchenmscem .gt_sourcenote { font-size: 90%; padding: 4px; } #xchenmscem .gt_left { text-align: left; } #xchenmscem .gt_center { text-align: center; } #xchenmscem .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #xchenmscem .gt_font_normal { font-weight: normal; } #xchenmscem .gt_font_bold { font-weight: bold; } #xchenmscem .gt_font_italic { font-style: italic; } #xchenmscem .gt_super { font-size: 65%; } #xchenmscem .gt_footnote_marks { font-style: italic; font-size: 65%; } Estimate Comparison Comparison of C-J-S apparent survival (phi) and recapture probability (p) estimates fit using JAGS, Stan, greta. Mean SD LCL UCL phi 0.65 NA NA NA 0.60 0.08 0.47 0.78 0.61 0.08 0.46 0.78 0.62 0.07 0.49 0.78 p 0.40 NA NA NA 0.44 0.08 0.29 0.60 0.43 0.08 0.28 0.60 0.46 0.07 0.32 0.61 5.2 Jolly-Seber "],["appendix-a.html", "A Appendix A A.1 Authors Guidelines", " A Appendix A A.1 Authors Guidelines We have decided to adapt the tidyverse style guide. Detailed content can be found here. tidyverse style guide Before committing code to the git repository, it should be styled using the styler package. Primary points are outlined below: - Use underscores (snake_case) to separate words in both variable and file names. - Use periods to separate words in function names File Names: chapter_1.Rmd --- Variable Names: observed_data When submitting a description of a new model use the template provided in Appendix B. However, if extenuating circumstances make the template in Appendix B untenable for a model, describe the reason for departure in the git commit message. Variables should be named with nouns, functions should be named with verbs Use dots to separate words in function names simulate.code &lt;- function(X) { } Label function arguments Spaces after commas not before Do not pad parentheses with spaces Pad operators with space foo == bar foo &lt;- bar foo + bar foo * bar "],["appendix-b.html", "B Appendix B B.1 Model Template", " B Appendix B B.1 Model Template ## Model Name Model description ### Algebra Algebraic model description in latex ### Simulation ```{r }r &#39;&#39;` simulated_data &lt;- 1 ``` ### Models {.tabset} ::: {.tab} &lt;button class=&quot;tablinks&quot; onclick=&quot;unrolltab(event,&#39;JAGS&#39;)&quot;&gt;JAGS&lt;/button&gt; &lt;button class=&quot;tablinks&quot; onclick=&quot;unrolltab(event,&#39;NIMBLE&#39;)&quot;&gt;NIMBLE&lt;/button&gt; &lt;button class=&quot;tablinks&quot; onclick=&quot;unrolltab(event, &#39;Stan&#39;)&quot;&gt;Stan&lt;/button&gt; &lt;button class=&quot;tablinks&quot; onclick=&quot;unrolltab(event, &#39;Greta&#39;)&quot;&gt;Greta&lt;/button&gt; ::: {#JAGS .tabcontent} #### JAGS model fit {-} ```{r ,eval = FALSE,warning=FALSE,message=FALSE,error=FALSE, results=&#39;hide&#39;}r &#39;&#39;` library(knitr) library(R2jags) data &lt;- list( ) model_string &lt;- textConnection( &quot; model { # Likelihood # Priors # Derived values } &quot; ) parameters &lt;- c( ) set_initial_value &lt;- function() { list( ) } ni &lt;- 10000 ; nt &lt;- 1 ; nb &lt;- 5000 ; nc &lt;- 3 model &lt;- jags(data, set_initial_value, parameters, model_string, n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb) ``` ::: ::: {#NIMBLE .tabcontent} #### NIMBLE model fit {-} ```r library(nimble) n_data &lt;- list( ) n_constants &lt;- list( ) Nimble_Code &lt;- nimbleCode({ # Likelihood # Priors # Derived values }) n_params &lt;- c( ) n_inits &lt;- list( ) Nimble_Model &lt;- nimbleModel( code = Nimble_Code, constants = n_constants, data = n_data, inits = n_inits ) MCMC_Model &lt;- configureMCMC(Nimble_Model, monitors = n_params, print = T, enableWAIC = F) Model1_MCMC &lt;- buildMCMC(MCMC_Model) Comp_Model &lt;- compileNimble( Nimble_Model, showCompilerOutput = TRUE ) Comp_Model &lt;- compileNimble(Model1_MCMC, project = Nimble_Model) niter=10000 Model_samples &lt;- runMCMC(Comp_Model, niter = niter, nburnin=niter/2,nchains=3,summary = TRUE) mcmc_combo(Model_samples$samples, pars = c(&quot;N&quot;, &quot;p&quot;)) round(Model_samples$summary$all.chains,2) ``` ::: ::: {#Stan .tabcontent} #### Stan {-} ```{r ,eval = FALSE,warning=FALSE,message=FALSE,error=FALSE, results=&#39;hide&#39;}r &#39;&#39;` library(knitr) library(rstan) data &lt;- list( ) stan_model &lt;- &quot; data { } parameters { } model { } generated quantities { } &quot; nc &lt;- 4 stan.samples &lt;- stan(model_code = stan_model, data = data, iter = 10000, chains = nc, cores = nc) ``` ::: ::: {#Greta .tabcontent} #### Greta {-} ```{r ,eval = FALSE,warning=FALSE,message=FALSE,error=FALSE, results=&#39;hide&#39;}r &#39;&#39;` library(greta) # priors # likelihood # derived parameter # defining the model m &lt;- model() #objects to sample # sampling draws &lt;- greta::mcmc(m, n_samples = 1000) ``` ```{r}r &#39;&#39;` plot(m) ``` ::: ::: ### Comparison ```{r , echo=FALSE, warning=FALSE}r``` #round(model$BUGSoutput$summary[c(1,3),c(1,2,3,7)],2) #jags #round(summary(stan.samples)$summary[c(2,1),c(1,3,4,8)],2) #stan #summary(draws) #greta #https://gt.rstudio.com/articles/intro-creating-gt-tables.html library(gt) library(tidyverse) results_df &lt;- data.frame( Sampler=c(), Parameter=c(), Mean=c(), SD=c(), LCL=c(), UCL=c() ) results_df %&gt;% dplyr::select(-Sampler,-Parameter) %&gt;% gt() %&gt;% tab_row_group( group = &quot;p&quot;, rows = 5:8 ) %&gt;% tab_row_group( group = &quot;N&quot;, rows = 1:4 ) %&gt;% tab_header( title = &quot;&quot;, subtitle = &quot;&quot; ) ``` "],["references.html", "References", " References Alho, J. M. 1990. Logistic Regression in CaptureRecapture Models. Biometrics 46 (3): 62335. Huggins, R. M. 1989. On the Statistical Analysis of Capture Experiments. Biometrika 76 (1): 13340. https://doi.org/10.2307/2336377. . 1991. Some Practical Aspects of a Conditional Likelihood Approach to Capture Experiments. Biometrics 47 (2): 72532. https://doi.org/10.2307/2532158. "]]
